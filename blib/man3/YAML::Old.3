.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "YAML::Old 3"
.TH YAML::Old 3 "2008-11-29" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
YAML::Old \- Old/Classic Perl YAML Module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use YAML::Old;
\&    
\&    # Load a YAML stream of 3 YAML documents into Perl data structures.
\&    my ($hashref, $arrayref, $string) = Load(<<\*(Aq...\*(Aq);
\&    \-\-\-
\&    name: ingy
\&    age: old
\&    weight: heavy
\&    # I should comment that I also like pink, but don\*(Aqt tell anybody.
\&    favorite colors:
\&        \- red
\&        \- green
\&        \- blue
\&    \-\-\-
\&    \- Clark Evans
\&    \- Oren Ben\-Kiki
\&    \- Ingy do\*:t Net
\&    \-\-\- >
\&    You probably think YAML stands for "Yet Another Markup Language". It
\&    ain\*(Aqt! YAML is really a data serialization language. But if you want
\&    to think of it as a markup, that\*(Aqs OK with me. A lot of people try
\&    to use XML as a serialization format.
\&    
\&    "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
\&    ...
\&    
\&    # Dump the Perl data structures back into YAML.
\&    print Dump($string, $arrayref, $hashref); 
\&    
\&    # YAML::Old::Dump is used the same way you\*(Aqd use Data::Dumper::Dumper
\&    use Data::Dumper;
\&    print Dumper($string, $arrayref, $hashref);
.Ve
.SH "NOTE"
.IX Header "NOTE"
YAML::Old is the old Perl \s-1YAML\s0 module. The old \s-1YAML\s0.pm that was on \s-1CPAN\s0
from the beginning of 2002 to the end of 2008. \s-1YAML\s0.pm has been made
into an interface only module.
.PP
For almost all of your old code you don't need to change anything. This
still works:
.PP
.Vb 2
\&    use YAML;
\&    my $clone = Load Dump $object;
.Ve
.PP
The difference is that now (the new) \s-1YAML\s0.pm will search for the best
\&\s-1YAML\s0 implementation module available on your system. See YAML::Any.
If you really need the behavior of the old \s-1YAML\s0.pm, do this:
.PP
.Vb 2
\&    use YAML::Old;
\&    my $clone = Load Dump $object;
.Ve
.PP
or this:
.PP
.Vb 2
\&    use YAML \-Old;
\&    my $clone = Load Dump $object;
.Ve
.PP
The rest of this documentation has largely been left alone. I changed
\&\s-1YAML\s0.pm to YAML::Old. Later I'll revamp it in more detail.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The YAML::Old module implements a \s-1YAML\s0 Loader and Dumper based on the \s-1YAML\s0
1.0 specification. <http://www.yaml.org/spec/>
.PP
\&\s-1YAML\s0 is a generic data serialization language that is optimized for
human readability. It can be used to express the data structures of most
modern programming languages. (Including Perl!!!)
.PP
For information on the \s-1YAML\s0 syntax, please refer to the \s-1YAML\s0
specification.
.SH "WHY YAML IS COOL"
.IX Header "WHY YAML IS COOL"
.IP "\s-1YAML\s0 is readable for people." 4
.IX Item "YAML is readable for people."
It makes clear sense out of complex data structures. You should find
that \s-1YAML\s0 is an exceptional data dumping tool. Structure is shown
through indentation, \s-1YAML\s0 supports recursive data, and hash keys are
sorted by default. In addition, \s-1YAML\s0 supports several styles of scalar
formatting for different types of data.
.IP "\s-1YAML\s0 is editable." 4
.IX Item "YAML is editable."
\&\s-1YAML\s0 was designed from the ground up to be an excellent syntax for
configuration files. Almost all programs need configuration files, so
why invent a new syntax for each one? And why subject users to the
complexities of \s-1XML\s0 or native Perl code?
.IP "\s-1YAML\s0 is multilingual." 4
.IX Item "YAML is multilingual."
Yes, \s-1YAML\s0 supports Unicode. But I'm actually referring to programming
languages. \s-1YAML\s0 was designed to meet the serialization needs of Perl,
Python, Ruby, Tcl, \s-1PHP\s0, Javascript and Java. It was also designed to be
interoperable between those languages. That means \s-1YAML\s0 serializations
produced by Perl can be processed by Python.
.IP "\s-1YAML\s0 is taint safe." 4
.IX Item "YAML is taint safe."
Using modules like Data::Dumper for serialization is fine as long as you
can be sure that nobody can tamper with your data files or
transmissions. That's because you need to use Perl's \f(CW\*(C`eval()\*(C'\fR built-in
to deserialize the data. Somebody could add a snippet of Perl to erase
your files.
.Sp
\&\s-1YAML\s0's parser does not need to eval anything.
.IP "\s-1YAML\s0 is full featured." 4
.IX Item "YAML is full featured."
\&\s-1YAML\s0 can accurately serialize all of the common Perl data structures and
deserialize them again without losing data relationships. Although it is
not 100% perfect (no serializer is or can be perfect), it fares as well
as the popular current modules: Data::Dumper, Storable, XML::Dumper and
Data::Denter.
.Sp
YAML::Old also has the ability to handle code (subroutine) references and
typeglobs. (Still experimental) These features are not found in Perl's
other serialization modules.
.IP "\s-1YAML\s0 is extensible." 4
.IX Item "YAML is extensible."
The \s-1YAML\s0 language has been designed to be flexible enough to solve it's
own problems. The markup itself has 3 basic construct which resemble
Perl's hash, array and scalar. By default, these map to their Perl
equivalents. But each \s-1YAML\s0 node also supports a tagging mechanism (type
system) which can cause that node to be interpreted in a completely
different manner. That's how \s-1YAML\s0 can support object serialization and
oddball structures like Perl's typeglob.
.SH "YAML IMPLEMENTATIONS IN PERL"
.IX Header "YAML IMPLEMENTATIONS IN PERL"
This module, YAML::Old, is really just the interface module for \s-1YAML\s0
modules written in Perl. The basic interface for \s-1YAML\s0 consists of two
functions: \f(CW\*(C`Dump\*(C'\fR and \f(CW\*(C`Load\*(C'\fR. The real work is done by the modules
YAML::Old::Dumper and YAML::Old::Loader.
.PP
Different \s-1YAML\s0 module distributions can be created by subclassing
YAML::Old and YAML::Old::Loader and YAML::Old::Dumper. For example, YAML-Simple
consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
.PP
Why would there be more than one implementation of \s-1YAML\s0? Well, despite
\&\s-1YAML\s0's offering of being a simple data format, \s-1YAML\s0 is actually very
deep and complex. Implementing the entirety of the \s-1YAML\s0 specification is
a daunting task.
.PP
For this reason I am currently working on 3 different \s-1YAML\s0 implementations.
.IP "YAML::Old" 4
.IX Item "YAML::Old"
The main \s-1YAML\s0 distribution will keeping evolving to support the entire
\&\s-1YAML\s0 specification in pure Perl. This may not be the fastest or most
stable module though. Currently, YAML::Old has lots of known bugs. It is
mostly a great tool for dumping Perl data structures to a readable form.
.IP "YAML::Lite" 4
.IX Item "YAML::Lite"
The point of YAML::Lite is to strip \s-1YAML\s0 down to the 90% that people
use most and offer that in a small, fast, stable, pure Perl form.
YAML::Lite will simply die when it is asked to do something it can't.
.IP "YAML::Syck" 4
.IX Item "YAML::Syck"
\&\f(CW\*(C`libsyck\*(C'\fR is the C based \s-1YAML\s0 processing library used by the Ruby
programming language (and also Python, \s-1PHP\s0 and Pugs). YAML::Syck is the
Perl binding to \f(CW\*(C`libsyck\*(C'\fR. It should be very fast, but may have
problems of its own. It will also require C compilation.
.Sp
\&\s-1NOTE:\s0 Audrey Tang has actually completed this module and it works great
      and is 10 times faster than YAML::Old.
.PP
In the future, there will likely be even more \s-1YAML\s0 modules. Remember,
people other than Ingy are allowed to write \s-1YAML\s0 modules!
.SH "FUNCTIONAL USAGE"
.IX Header "FUNCTIONAL USAGE"
YAML::Old is completely \s-1OO\s0 under the hood. Still it exports a few useful top
level functions so that it is dead simple to use. These functions just
do the \s-1OO\s0 stuff for you. If you want direct access to the \s-1OO\s0 \s-1API\s0 see the
documentation for YAML::Old::Dumper and YAML::Old::Loader.
.Sh "Exported Functions"
.IX Subsection "Exported Functions"
The following functions are exported by YAML::Old by default. The reason
they are exported is so that YAML::Old works much like Data::Dumper. If you
don't want functions to be imported, just use YAML::Old with an empty
import list:
.PP
.Vb 1
\&    use YAML::Old ();
.Ve
.IP "Dump(list\-of\-Perl\-data\-structures)" 4
.IX Item "Dump(list-of-Perl-data-structures)"
Turn Perl data into \s-1YAML\s0. This function works very much like
\&\fIData::Dumper::Dumper()\fR. It takes a list of Perl data strucures and
dumps them into a serialized form. It returns a string containing the
\&\s-1YAML\s0 stream. The structures can be references or plain scalars.
.IP "Load(string\-containing\-a\-YAML\-stream)" 4
.IX Item "Load(string-containing-a-YAML-stream)"
Turn \s-1YAML\s0 into Perl data. This is the opposite of Dump. Just like
Storable's \fIthaw()\fR function or the \fIeval()\fR function in relation to
Data::Dumper. It parses a string containing a valid \s-1YAML\s0 stream into a
list of Perl data structures.
.Sh "Exportable Functions"
.IX Subsection "Exportable Functions"
These functions are not exported by default but you can request them in
an import list like this:
.PP
.Vb 1
\&    use YAML::Old qw\*(Aqfreeze thaw Bless\*(Aq;
.Ve
.IP "\fIfreeze()\fR and \fIthaw()\fR" 4
.IX Item "freeze() and thaw()"
Aliases to \fIDump()\fR and \fILoad()\fR for Storable fans. This will also allow
YAML::Old to be plugged directly into modules like \s-1POE\s0.pm, that use the
freeze/thaw \s-1API\s0 for internal serialization.
.IP "DumpFile(filepath, list)" 4
.IX Item "DumpFile(filepath, list)"
Writes the \s-1YAML\s0 stream to a file instead of just returning a string.
.IP "LoadFile(filepath)" 4
.IX Item "LoadFile(filepath)"
Reads the \s-1YAML\s0 stream from a file instead of a string.
.IP "Bless(perl\-node, [yaml\-node | class\-name])" 4
.IX Item "Bless(perl-node, [yaml-node | class-name])"
Associate a normal Perl node, with a yaml node. A yaml node is an object
tied to the YAML::Old::Node class. The second argument is either a yaml node
that you've already created or a class (package) name that supports a
\&\fIyaml_dump()\fR function. A \fIyaml_dump()\fR function should take a perl node and
return a yaml node. If no second argument is provided, Bless will create
a yaml node. This node is not returned, but can be retrieved with the
\&\fIBlessed()\fR function.
.Sp
Here's an example of how to use Bless. Say you have a hash containing
three keys, but you only want to dump two of them. Furthermore the keys
must be dumped in a certain order. Here's how you do that:
.Sp
.Vb 5
\&    use YAML::Old qw(Dump Bless);
\&    $hash = {apple => \*(Aqgood\*(Aq, banana => \*(Aqbad\*(Aq, cauliflower => \*(Aqugly\*(Aq};
\&    print Dump $hash;
\&    Bless($hash)\->keys([\*(Aqbanana\*(Aq, \*(Aqapple\*(Aq]);
\&    print Dump $hash;
.Ve
.Sp
produces:
.Sp
.Vb 7
\&    \-\-\-
\&    apple: good
\&    banana: bad
\&    cauliflower: ugly
\&    \-\-\-
\&    banana: bad
\&    apple: good
.Ve
.Sp
Bless returns the tied part of a yaml-node, so that you can call the
YAML::Old::Node methods. This is the same thing that \fIYAML::Old::Node::ynode()\fR
returns. So another way to do the above example is:
.Sp
.Vb 8
\&    use YAML::Old qw(Dump Bless);
\&    use YAML::Old::Node;
\&    $hash = {apple => \*(Aqgood\*(Aq, banana => \*(Aqbad\*(Aq, cauliflower => \*(Aqugly\*(Aq};
\&    print Dump $hash;
\&    Bless($hash);
\&    $ynode = ynode(Blessed($hash));
\&    $ynode\->keys([\*(Aqbanana\*(Aq, \*(Aqapple\*(Aq]);
\&    print Dump $hash;
.Ve
.Sp
Note that Blessing a Perl data structure does not change it anyway. The
extra information is stored separately and looked up by the Blessed
node's memory address.
.IP "Blessed(perl\-node)" 4
.IX Item "Blessed(perl-node)"
Returns the yaml node that a particular perl node is associated with
(see above). Returns undef if the node is not (YAML::Old) Blessed.
.SH "GLOBAL OPTIONS"
.IX Header "GLOBAL OPTIONS"
YAML::Old options are set using a group of global variables in the YAML::Old
namespace. This is similar to how Data::Dumper works.
.PP
For example, to change the indentation width, do something like:
.PP
.Vb 1
\&    local $YAML::Old::Indent = 3;
.Ve
.PP
The current options are:
.IP "DumperClass" 4
.IX Item "DumperClass"
You can override which module/class YAML::Old uses for Dumping data.
.IP "LoaderClass" 4
.IX Item "LoaderClass"
You can override which module/class YAML::Old uses for Loading data.
.IP "Indent" 4
.IX Item "Indent"
This is the number of space characters to use for each indentation level
when doing a \fIDump()\fR. The default is 2.
.Sp
By the way, \s-1YAML\s0 can use any number of characters for indentation at any
level. So if you are editing \s-1YAML\s0 by hand feel free to do it anyway that
looks pleasing to you; just be consistent for a given level.
.IP "SortKeys" 4
.IX Item "SortKeys"
Default is 1. (true)
.Sp
Tells YAML::Old whether or not to sort hash keys when storing a document.
.Sp
YAML::Old::Node objects can have their own sort order, which is usually what
you want. To override the YAML::Old::Node order and sort the keys anyway, set
SortKeys to 2.
.IP "Stringify" 4
.IX Item "Stringify"
Default is 0. (false)
.Sp
Objects with string overloading should honor the overloading and dump the
stringification of themselves, rather than the actual object's guts.
.IP "UseHeader" 4
.IX Item "UseHeader"
Default is 1. (true)
.Sp
This tells YAML::Old whether to use a separator string for a Dump
operation. This only applies to the first document in a stream.
Subsequent documents must have a \s-1YAML\s0 header by definition.
.IP "UseVersion" 4
.IX Item "UseVersion"
Default is 0. (false)
.Sp
Tells YAML::Old whether to include the \s-1YAML\s0 version on the
separator/header.
.Sp
.Vb 1
\&    \-\-\- %YAML:1.0
.Ve
.IP "AnchorPrefix" 4
.IX Item "AnchorPrefix"
Default is ''.
.Sp
Anchor names are normally numeric. YAML::Old simply starts with '1' and
increases by one for each new anchor. This option allows you to specify a
string to be prepended to each anchor number.
.IP "UseCode" 4
.IX Item "UseCode"
Setting the UseCode option is a shortcut to set both the DumpCode and
LoadCode options at once. Setting UseCode to '1' tells YAML::Old to dump
Perl code references as Perl (using B::Deparse) and to load them back
into memory using \fIeval()\fR. The reason this has to be an option is that
using \fIeval()\fR to parse untrusted code is, well, untrustworthy.
.IP "DumpCode" 4
.IX Item "DumpCode"
Determines if and how YAML::Old should serialize Perl code references. By
default YAML::Old will dump code references as dummy placeholders (much
like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
references will be dumped as actual Perl code.
.Sp
DumpCode can also be set to a subroutine reference so that you can
write your own serializing routine. YAML::Old passes you the code ref. You
pass back the serialization (as a string) and a format indicator. The
format indicator is a simple string like: 'deparse' or 'bytecode'.
.IP "LoadCode" 4
.IX Item "LoadCode"
LoadCode is the opposite of DumpCode. It tells YAML::Old if and how to
deserialize code references. When set to '1' or 'deparse' it will use
\&\f(CW\*(C`eval()\*(C'\fR. Since this is potentially risky, only use this option if you
know where your \s-1YAML\s0 has been.
.Sp
LoadCode can also be set to a subroutine reference so that you can write
your own deserializing routine. YAML::Old passes the serialization (as a
string) and a format indicator. You pass back the code reference.
.IP "UseBlock" 4
.IX Item "UseBlock"
YAML::Old uses heuristics to guess which scalar style is best for a given
node. Sometimes you'll want all multiline scalars to use the 'block'
style. If so, set this option to 1.
.Sp
\&\s-1NOTE:\s0 \s-1YAML\s0's block style is akin to Perl's here-document.
.IP "UseFold" 4
.IX Item "UseFold"
If you want to force YAML::Old to use the 'folded' style for all multiline
scalars, then set \f(CW$UseFold\fR to 1.
.Sp
\&\s-1NOTE:\s0 \s-1YAML\s0's folded style is akin to the way \s-1HTML\s0 folds text,
      except smarter.
.IP "UseAliases" 4
.IX Item "UseAliases"
\&\s-1YAML\s0 has an alias mechanism such that any given structure in memory gets
serialized once. Any other references to that structure are serialized
only as alias markers. This is how \s-1YAML\s0 can serialize duplicate and
recursive structures.
.Sp
Sometimes, when you \s-1KNOW\s0 that your data is nonrecursive in nature, you
may want to serialize such that every node is expressed in full. (ie as
a copy of the original). Setting \f(CW$YAML::Old::UseAliases\fR to 0 will allow you
to do this. This also may result in faster processing because the lookup
overhead is by bypassed.
.Sp
\&\s-1THIS\s0 \s-1OPTION\s0 \s-1CAN\s0 \s-1BE\s0 \s-1DANGEROUS\s0. *If* your data is recursive, this option
*will* cause \fIDump()\fR to run in an endless loop, chewing up your computers
memory. You have been warned.
.IP "CompressSeries" 4
.IX Item "CompressSeries"
Default is 1.
.Sp
Compresses the formatting of arrays of hashes:
.Sp
.Vb 4
\&    \-
\&      foo: bar
\&    \- 
\&      bar: foo
.Ve
.Sp
becomes:
.Sp
.Vb 2
\&    \- foo: bar
\&    \- bar: foo
.Ve
.Sp
Since this output is usually more desirable, this option is turned on by
default.
.SH "YAML TERMINOLOGY"
.IX Header "YAML TERMINOLOGY"
\&\s-1YAML\s0 is a full featured data serialization language, and thus has its
own terminology.
.PP
It is important to remember that although \s-1YAML\s0 is heavily influenced by
Perl and Python, it is a language in its own right, not merely just a
representation of Perl structures.
.PP
\&\s-1YAML\s0 has three constructs that are conspicuously similar to Perl's hash,
array, and scalar. They are called mapping, sequence, and string
respectively. By default, they do what you would expect. But each
instance may have an explicit or implicit tag (type) that makes it
behave differently. In this manner, \s-1YAML\s0 can be extended to represent
Perl's Glob or Python's tuple, or Ruby's Bigint.
.IP "stream" 4
.IX Item "stream"
A \s-1YAML\s0 stream is the full sequence of unicode characters that a \s-1YAML\s0
parser would read or a \s-1YAML\s0 emitter would write. A stream may contain
one or more \s-1YAML\s0 documents separated by \s-1YAML\s0 headers.
.Sp
.Vb 6
\&    \-\-\-
\&    a: mapping
\&    foo: bar
\&    \-\-\-
\&    \- a
\&    \- sequence
.Ve
.IP "document" 4
.IX Item "document"
A \s-1YAML\s0 document is an independent data structure representation within a
stream. It is a top level node. Each document in a \s-1YAML\s0 stream must
begin with a \s-1YAML\s0 header line. Actually the header is optional on the
first document.
.Sp
.Vb 6
\&    \-\-\-
\&    This: top level mapping
\&    is:
\&        \- a
\&        \- YAML
\&        \- document
.Ve
.IP "header" 4
.IX Item "header"
A \s-1YAML\s0 header is a line that begins a \s-1YAML\s0 document. It consists of
three dashes, possibly followed by more info. Another purpose of the
header line is that it serves as a place to put top level tag and anchor
information.
.Sp
.Vb 3
\&    \-\-\- !recursive\-sequence &001
\&    \- * 001
\&    \- * 001
.Ve
.IP "node" 4
.IX Item "node"
A \s-1YAML\s0 node is the representation of a particular data stucture. Nodes
may contain other nodes. (In Perl terms, nodes are like scalars.
Strings, arrayrefs and hashrefs. But this refers to the serialized
format, not the in-memory structure.)
.IP "tag" 4
.IX Item "tag"
This is similar to a type. It indicates how a particular \s-1YAML\s0 node
serialization should be transferred into or out of memory. For instance
a Foo::Bar object would use the tag 'perl/Foo::Bar':
.Sp
.Vb 3
\&    \- !perl/Foo::Bar
\&        foo: 42
\&        bar: stool
.Ve
.IP "collection" 4
.IX Item "collection"
A collection is the generic term for a \s-1YAML\s0 data grouping. \s-1YAML\s0 has two
types of collections: mappings and sequences. (Similar to hashes and arrays)
.IP "mapping" 4
.IX Item "mapping"
A mapping is a \s-1YAML\s0 collection defined by unordered key/value pairs with
unique keys. By default \s-1YAML\s0 mappings are loaded into Perl hashes.
.Sp
.Vb 3
\&    a mapping:
\&        foo: bar
\&        two: times two is 4
.Ve
.IP "sequence" 4
.IX Item "sequence"
A sequence is a \s-1YAML\s0 collection defined by an ordered list of elements. By
default \s-1YAML\s0 sequences are loaded into Perl arrays.
.Sp
.Vb 4
\&    a sequence:
\&        \- one bourbon
\&        \- one scotch
\&        \- one beer
.Ve
.IP "scalar" 4
.IX Item "scalar"
A scalar is a \s-1YAML\s0 node that is a single value. By default \s-1YAML\s0 scalars
are loaded into Perl scalars.
.Sp
.Vb 1
\&    a scalar key: a scalar value
.Ve
.Sp
\&\s-1YAML\s0 has many styles for representing scalars. This is important because
varying data will have varying formatting requirements to retain the
optimum human readability.
.IP "plain scalar" 4
.IX Item "plain scalar"
A plain sclar is unquoted. All plain scalars are automatic candidates
for \*(L"implicit tagging\*(R". This means that their tag may be determined
automatically by examination. The typical uses for this are plain alpha
strings, integers, real numbers, dates, times and currency.
.Sp
.Vb 5
\&    \- a plain string
\&    \- \-42
\&    \- 3.1415
\&    \- 12:34
\&    \- 123 this is an error
.Ve
.IP "single quoted scalar" 4
.IX Item "single quoted scalar"
This is similar to Perl's use of single quotes. It means no escaping
except for single quotes which are escaped by using two adjacent
single quotes.
.Sp
.Vb 1
\&    \- \*(AqWhen I say \*(Aq\*(Aq\en\*(Aq\*(Aq I mean "backslash en"\*(Aq
.Ve
.IP "double quoted scalar" 4
.IX Item "double quoted scalar"
This is similar to Perl's use of double quotes. Character escaping can
be used.
.Sp
.Vb 1
\&    \- "This scalar\enhas two lines, and a bell \-\->\ea"
.Ve
.IP "folded scalar" 4
.IX Item "folded scalar"
This is a multiline scalar which begins on the next line. It is
indicated by a single right angle bracket. It is unescaped like the
single quoted scalar. Line folding is also performed.
.Sp
.Vb 6
\&    \- > 
\&     This is a multiline scalar which begins on
\&     the next line. It is indicated by a single
\&     carat. It is unescaped like the single
\&     quoted scalar. Line folding is also
\&     performed.
.Ve
.IP "block scalar" 4
.IX Item "block scalar"
This final multiline form is akin to Perl's here-document except that
(as in all \s-1YAML\s0 data) scope is indicated by indentation. Therefore, no
ending marker is required. The data is verbatim. No line folding.
.Sp
.Vb 5
\&    \- |
\&        QTY  DESC          PRICE  TOTAL
\&        \-\-\-  \-\-\-\-          \-\-\-\-\-  \-\-\-\-\-
\&          1  Foo Fighters  $19.95 $19.95
\&          2  Bar Belles    $29.95 $59.90
.Ve
.IP "parser" 4
.IX Item "parser"
A \s-1YAML\s0 processor has four stages: parse, load, dump, emit.
.Sp
A parser parses a \s-1YAML\s0 stream. YAML::Old's \fILoad()\fR function contains a
parser.
.IP "loader" 4
.IX Item "loader"
The other half of the \fILoad()\fR function is a loader. This takes the
information from the parser and loads it into a Perl data structure.
.IP "dumper" 4
.IX Item "dumper"
The \fIDump()\fR function consists of a dumper and an emitter. The dumper
walks through each Perl data structure and gives info to the emitter.
.IP "emitter" 4
.IX Item "emitter"
The emitter takes info from the dumper and turns it into a \s-1YAML\s0 stream.
.Sp
\&\s-1NOTE:\s0 
In YAML::Old the parser/loader and the dumper/emitter code are currently
very closely tied together. In the future they may be broken into
separate stages.
.PP
For more information please refer to the immensely helpful \s-1YAML\s0
specification available at <http://www.yaml.org/spec/>.
.SH "ysh \- The YAML Shell"
.IX Header "ysh - The YAML Shell"
The YAML::Old distribution ships with a script called 'ysh', the \s-1YAML\s0 shell.
ysh provides a simple, interactive way to play with \s-1YAML\s0. If you type in
Perl code, it displays the result in \s-1YAML\s0. If you type in \s-1YAML\s0 it turns
it into Perl code.
.PP
To run ysh, (assuming you installed it along with YAML::Old) simply type:
.PP
.Vb 1
\&    ysh [options]
.Ve
.PP
Please read the \f(CW\*(C`ysh\*(C'\fR documentation for the full details. There are
lots of options.
.SH "BUGS & DEFICIENCIES"
.IX Header "BUGS & DEFICIENCIES"
If you find a bug in YAML::Old, please try to recreate it in the \s-1YAML\s0 Shell
with logging turned on ('ysh \-L'). When you have successfully reproduced
the bug, please mail the \s-1LOG\s0 file to the author (ingy@cpan.org).
.PP
\&\s-1WARNING:\s0 This is still *ALPHA* code. Well, most of this code has been
around for years...
.PP
\&\s-1BIGGER\s0 \s-1WARNING:\s0 YAML::Old has been slow in the making, but I am committed
to having top notch \s-1YAML\s0 tools in the Perl world. The \s-1YAML\s0 team is close
to finalizing the \s-1YAML\s0 1.1 spec. This version of YAML::Old is based off of
a very old pre 1.0 spec. In actuality there isn't a ton of difference,
and this YAML::Old is still fairly useful. Things will get much better in
the future.
.SH "RESOURCES"
.IX Header "RESOURCES"
<http://lists.sourceforge.net/lists/listinfo/yaml\-core> is the mailing
list. This is where the language is discussed and designed.
.PP
<http://www.yaml.org> is the official \s-1YAML\s0 website.
.PP
<http://www.yaml.org/spec/> is the \s-1YAML\s0 1.0 specification.
.PP
<http://yaml.kwiki.org> is the official \s-1YAML\s0 wiki.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See YAML::Syck. Fast!
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy do\*:t Net <ingy@cpan.org>
.PP
is resonsible for YAML::Old.
.PP
The \s-1YAML\s0 serialization language is the result of years of collaboration
between Oren Ben-Kiki, Clark Evans and Ingy do\*:t Net. Several others
have added help along the way.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005, 2006, 2008. Ingy do\*:t Net.
.PP
Copyright (c) 2001, 2002, 2005. Brian Ingerson.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
